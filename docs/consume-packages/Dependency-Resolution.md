---
title: Разрешение зависимостей для пакетов NuGet
description: Сведения о процессе разрешения зависимостей для пакета NuGet и их установки в NuGet 2.x и NuGet 3.x+.
author: karann-msft
ms.author: karann
ms.date: 08/14/2017
ms.topic: conceptual
ms.openlocfilehash: a2aed3950b3e19e30d9d026ad1b9bdaef44c9d37
ms.sourcegitcommit: 1ab750ff17e55c763d646c50e7630138804ce8b8
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/14/2019
ms.locfileid: "56247650"
---
# <a name="how-nuget-resolves-package-dependencies"></a>Принципы разрешения зависимостей пакетов в NuGet

При любой установке или переустановке пакета, включая установку в рамках процесса [восстановления](../consume-packages/package-restore.md), NuGet также устанавливает все дополнительные пакеты, от которых зависит этот первый пакет.

Эти прямые зависимости также могут иметь собственные зависимости, уходящие на произвольную глубину. В результате образуется так называемая *схема зависимостей*, описывающая связи между пакетами на всех уровнях.

Если несколько пакетов имеют одинаковую зависимость, один идентификатор пакета может отображаться на графе несколько раз, возможно, с другими ограничениями по версиям. Однако в проекте можно использовать только одну версию заданного пакета, поэтому NuGet нужно выбрать подходящую версию. Конкретная процедура зависит от используемого формата управления пакетами.

## <a name="dependency-resolution-with-packagereference"></a>Разрешение зависимостей при использовании PackageReference

При установке пакетов в проекты с использованием формата PackageReference, NuGet добавляет ссылки на плоскую схему пакета в соответствующий файл и разрешает конфликты заранее. Этот процесс называется *транзитивным восстановлением*. В этом случае переустановка или восстановление пакетов представляют собой скачивание пакетов, указанных на графе, в результате чего сборки выполняются быстрее и более предсказуемо. Вы также можете воспользоваться преимуществами групповых версий, таких как 2.8. \*, избавившись от ресурсоемких и подверженных ошибкам вызовов `nuget update` на клиентских компьютерах и серверах сборки.

Когда перед сборкой выполняется процесс восстановления NuGet, он сначала устраняет зависимости в памяти, а затем записывает полученную схему в файл с именем `project.assets.json`. Файл ресурсов находится в каталоге `MSBuildProjectExtensionsPath`, по умолчанию — это папка "obj". После этого MSBuild считывает этот файл и преобразует его в набор папок, где можно найти потенциальные ссылки, а затем добавляет их в дерево проектов в памяти.

Файл блокировки является временным, поэтому добавлять его в систему управления исходным кодом не нужно. Он указан по умолчанию в `.gitignore` и `.tfignore`. См. раздел [Пакеты и система управления версиями](packages-and-source-control.md).

### <a name="dependency-resolution-rules"></a>Правила разрешения зависимостей

Для разрешения зависимостей транзитивное восстановление применяет четыре основных правила: минимально приемлемая версия, групповые версии, ближайшее совпадение и родственные зависимости.

<a name="lowest-applicable-version"></a>

#### <a name="lowest-applicable-version"></a>Минимально приемлемая версия

Правило минимально приемлемой версии восстанавливает наименьшую версию пакета, определяемую его зависимостями. Она также применяется к зависимостям для приложения и библиотеки классов, если только та не объявлена как [групповая](#floating-versions).

Например, на следующем рисунке 1.0-beta считается ниже, чем 1.0, поэтому NuGet выбирает версию 1.0:

![Выбор минимально приемлемой версии](media/projectJson-dependency-1.png)

На следующем рисунке версия 2.1 недоступна в веб-канале, но так как ограничение по версии имеет значение >= 2.1, NuGet выбирает следующую наименьшую версию, которую может найти, в данном случае это 2.2:

![Выбор следующей наименьшей версии из доступных в веб-канале](media/projectJson-dependency-2.png)

Если приложение указывает точный номер версии, например 1.2, который недоступен в веб-канале, NuGet завершается с ошибкой при попытке установить или восстановить этот пакет:

![NuGet выдает ошибку, если точная версия пакета недоступна](media/projectJson-dependency-3.png)

<a name="floating-versions"></a>

#### <a name="floating-wildcard-versions"></a>Групповые версии

Групповая версия зависимости указывается с помощью подстановочного знака \*, например 6.0.\*. Такая запись версии указывает, что нужно использовать самую последнюю версию 6.0.x. Если указано 4.\*, нужно использовать последнюю версию 4.x. Использование подстановочного знака позволяет последовательно дорабатывать пакет зависимостей без внесения изменений в использующее его приложение (или пакет).

При наличии подстановочного знака NuGet разрешает самую новую версию пакета, соответствующую заданному шаблону. Например, при значении 6.0.\* используется самая новая версия пакета, начинающаяся с 6.0:

![Выбор версии 6.0.1, когда запрошена групповая версия 6.0.*](media/projectJson-dependency-4.png)

> [!Note]
> Сведения о работе групповых и предварительных версий см. в разделе [Управление версиями пакетов](../reference/package-versioning.md#version-ranges-and-wildcards).


<a name="nearest-wins"></a>

#### <a name="nearest-wins"></a>Ближайшее совпадение

Если граф пакетов для приложения содержит разные версии одного пакета, NuGet выбирает пакет, который находится ближе всего к приложению на графе, и игнорирует остальные. Такое поведение позволяет приложению переопределить любую конкретную версию пакета на графе зависимостей.

В следующем примере приложение зависит непосредственно от пакета B с ограничением по версии >=2.0. Кроме того, приложение зависит от пакета A, который, в свою очередь, зависит от пакета B, но с ограничением >=1.0. Так как в графе зависимость от версии 2.0 пакета B находится ближе всего к приложению, используется эта версия:

![Приложение, использующее правило ближайшего совпадения](media/projectJson-dependency-5.png)

>[!Warning]
> Правило ближайшего совпадения может привести к понижению версии пакета, что способно нарушить другие зависимости на графе. Поэтому при использовании данного правила выдается предупреждение для пользователя.

Кроме того, это правило также эффективнее работает с крупным графом зависимостей (например, как в случае с пакетами BCL), так как после пропуска заданной зависимости NuGet также игнорирует все оставшиеся зависимости в этой ветви графа. На следующей схеме из-за использования версии 2.0 пакета C NuGet игнорирует все ветви графа, относящиеся к более старой версии пакета C:

![Если NuGet игнорирует пакет на графе, он пропускает всю эту ветвь](media/projectJson-dependency-6.png)

<a name="cousin-dependencies"></a>

#### <a name="cousin-dependencies"></a>Родственные зависимости

Когда на графе разные версии пакета находятся на одинаковом удалении от приложения, NuGet использует самую раннюю версию, удовлетворяющую всем требованиям к версии (как в случае с правилами [минимально приемлемой версии](#lowest-applicable-version) и [групповых версий](#floating-versions)). Например, на рисунке ниже версия 2.0 пакета B удовлетворяет другому ограничению версии >=1.0 и поэтому используется:

![Разрешение родственных зависимостей с помощью наиболее ранней версии, удовлетворяющей всем ограничениям](media/projectJson-dependency-7.png)

В некоторых случаях удовлетворить все требования к версии невозможно. Как показано ниже, если пакету A требуется именно версия 1.0 пакета B, а пакету C требуется пакет B версии >=2.0, то NuGet не может разрешить эти зависимости и выдает ошибку.

![Неразрешаемые зависимости из-за потребности в точной версии](media/projectJson-dependency-8.png)

В таких ситуациях потребителю верхнего уровня (приложение или пакет) следует добавить собственную прямую зависимость от пакета B, чтобы применялось правило [ближайшего совпадения](#nearest-wins).

## <a name="dependency-resolution-with-packagesconfig"></a>Разрешение зависимостей для packages.config

При использовании `packages.config` зависимости проекта записываются в `packages.config` в виде плоского списка. Все зависимости этих пакетов также записываются в тот же список. При установке пакетов NuGet также может изменить файл `.csproj`, `app.config`, `web.config` и другие отдельные файлы.

При использовании `packages.config` NuGet пытается разрешить конфликты зависимостей во время установки каждого отдельного пакета. Таким образом, если устанавливается пакет A, зависящий от пакета B, а пакет B уже указан в `packages.config` в качестве зависимости для чего-то еще, NuGet сравнивает запрошенные версии пакета B и пытается найти ту из них, которая соответствует всем ограничениям по версиям. В частности, NuGet выбирает более низкую версию *основной_номер.дополнительный_номер*, которая удовлетворяет зависимостям.

По умолчанию NuGet 2.8 ищет самую раннюю версию исправления (см. [заметки о выпуске NuGet 2.8](../release-notes/nuget-2.8.md#patch-resolution-for-dependencies)). Вы можете управлять этим параметром с помощью атрибута `DependencyVersion` в `Nuget.Config` и параметра `-DependencyVersion` в командной строке.  

Для более крупных графов процесс разрешения зависимостей `packages.config` усложняется. При каждой новой установке пакета требуется обход всего графа, а также повышается вероятность конфликтов версий. При возникновении конфликта установка останавливается, оставляя проект в неопределенном состоянии, что особенно касается потенциальных изменений в файле проекта. Эта проблема не актуальна при использовании других форматов управления пакетами.

## <a name="managing-dependency-assets"></a>Управление ресурсами зависимостей

При использовании формата PackageReference вы можете управлять тем, какие ресурсы из зависимостей переходят в проект верхнего уровня. Дополнительные сведения см. в разделе [Управление ресурсами зависимости](package-references-in-project-files.md#controlling-dependency-assets).

Если проект верхнего уровня сам является пакетом, вы также можете управлять этим потоком, используя атрибуты `include` и `exclude` для зависимостей, перечисленных в файле `.nuspec`. См. подраздел "Зависимости" в разделе [Справочник по файлам NUSPEC](../reference/nuspec.md#dependencies).

## <a name="excluding-references"></a>Исключение ссылок

Существуют сценарии, когда проект может ссылаться на сборки с одинаковым именем несколько раз, что вызывает ошибки времени разработки и времени сборки. Рассмотрим проект, который содержит настраиваемую версию `C.dll` и ссылается на пакет C, который также содержит `C.dll`. В то же время проект зависит от пакета B, который, в свою очередь, зависит от пакета C и `C.dll`. В результате NuGet не может определить, какую `C.dll` использовать. Однако вы не можете просто удалить зависимость проекта от пакета C, так как от него зависит и пакет B.

Чтобы разрешить эту ситуацию, нужно напрямую сослаться на нужную `C.dll` (или использовать другой пакет с правильной ссылкой) и затем добавить зависимость от пакета C, которая исключает все его ресурсы. Это делается следующим образом в зависимости от используемого формата управления пакетами:

- [PackageReference](../consume-packages/package-references-in-project-files.md): добавьте `ExcludeAssets="All"` в зависимость:

    ```xml
    <PackageReference Include="PackageC" Version="1.0.0" ExcludeAssets="All" />
    ```

- `packages.config`: удалите ссылку на пакет PackageC из файла `.csproj`, чтобы он ссылался только на нужную версию `C.dll`.
    
## <a name="dependency-updates-during-package-install"></a>Обновление зависимостей при установке пакета 

Если версия зависимости уже удовлетворена, зависимость не обновляется при установке других пакетов. Например, рассмотрим пакет A, который зависит от пакета B и указывает номер версии 1.0. Исходный репозиторий содержит версии 1.0, 1.1 и 1.2 пакета B. Если установить пакет A в проекте, который уже содержит версию 1.0 пакета B, то пакет B версии 1.0 все еще будет использоваться, так как это удовлетворяет ограничение по версии. Однако если бы пакет A запрашивал для пакета B версию 1.1 или более позднюю, был бы установлен пакет B версии 1.2. 

## <a name="resolving-incompatible-package-errors"></a>Устранение ошибок с несовместимостью пакетов

При операции восстановления пакета вы можете увидеть ошибку "One or more packages are not compatible" (Один или несколько пакетов несовместимы) или сообщение о несовместимости пакета с целевой платформой проекта.

Эта ошибка возникает, когда один или несколько пакетов, на которые ссылается ваш проект, не сообщают о поддержке целевой платформы проекта. В результате пакет не содержит подходящую библиотеку DLL в своей папке `lib` для целевой платформы, совместимой с этим проектом. (Список см. в разделе [Целевые платформы](../reference/target-frameworks.md).) 

Например, если проект предназначен для `netstandard1.6` и вы пытаетесь установить пакет, содержащий библиотеки DLL, только в папках `lib\net20` и `\lib\net45`, то для пакета и, возможно, его зависимостей могут отображаться следующие сообщения:

```output
Restoring packages for myproject.csproj...
Package ContosoUtilities 2.1.2.3 is not compatible with netstandard1.6 (.NETStandard,Version=v1.6). Package ContosoUtilities 2.1.2.3 supports:
  - net20 (.NETFramework,Version=v2.0)
  - net45 (.NETFramework,Version=v4.5)
Package ContosoCore 0.86.0 is not compatible with netstandard1.6 (.NETStandard,Version=v1.6). Package ContosoCore 0.86.0 supports:
  - 11 (11,Version=v0.0)
  - net20 (.NETFramework,Version=v2.0)
  - sl3 (Silverlight,Version=v3.0)
  - sl4 (Silverlight,Version=v4.0)
One or more packages are incompatible with .NETStandard,Version=v1.6.
Package restore failed. Rolling back package changes for 'MyProject'.
```

Для устранения этих проблем совместимости выполните одно из следующих действий:

- Переориентируйте проект на платформу, которая поддерживается нужными вам пакетами.
- Обратитесь к автору пакетов и помогите ему добавить поддержку для выбранной вами платформы. Для этого на каждой странице с описанием пакета на сайте [nuget.org](https://www.nuget.org/) предусмотрена ссылка **Contact Owners** (Связаться с владельцами).

