---
title: Файл project.json NuGet и проекты UWP
description: Сведения об использовании файла project.json для отслеживания зависимостей NuGet в проектах универсальной платформы Windows (UWP).
author: JonDouglas
ms.author: jodou
ms.date: 07/17/2017
ms.topic: conceptual
ms.openlocfilehash: 30e2272aafb5d2ea8d932e3cb0209d97c30b3209
ms.sourcegitcommit: ee6c3f203648a5561c809db54ebeb1d0f0598b68
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/26/2021
ms.locfileid: "98773800"
---
# <a name="projectjson-and-uwp"></a>project.json и UWP

> [!Important]
> Это содержимое является устаревшим. Проекты должны использовать формат `packages.config` или PackageReference.

Этот документ описывает структуру пакета, в которой используются функции NuGet 3+ (Visual Studio 2015 и более поздних версий). Задав для свойства `minClientVersion` вашего `.nuspec` значение 3.1, вы можете указать потребность в описанных здесь функциях.

## <a name="adding-uwp-support-to-an-existing-package"></a>Добавление поддержки UWP для существующего пакета

Если у вас есть пакет и вы хотите добавить поддержку приложений UWP, то вам не нужно внедрять описанный здесь формат упаковки. Это требуется только в том случае, если вы нуждаетесь в описанных в этом формате функциях и хотите работать только с клиентами, которые были обновлены до версии 3+ клиента NuGet.

## <a name="i-already-target-netcore45"></a>Я уже ориентируюсь на netcore45

Если вы уже ориентируетесь на `netcore45` и не хотите воспользоваться преимуществами описанных здесь функций, никаких действий не требуется. Пакеты `netcore45` могут использоваться в приложениях UWP.

## <a name="i-want-to-take-advantage-of-windows-10-specific-apis"></a>Я хочу использовать преимущества конкретных API для Windows 10

В этом случае вам нужно добавить в пакет моникер целевой платформы `uap10.0` (TFM или TxM). Создайте в пакете папку и добавьте в нее сборку, скомпилированную для работы с Windows 10.

## <a name="i-dont-need-windows-10-specific-apis-but-want-new-net-features-or-dont-have-netcore45-already"></a>Мне не нужны конкретные API для Windows 10, но требуются новые возможности .NET, либо у меня еще нет netcore45

В этом случае нужно добавить TxM `dotnet` в пакет. В отличие от других TxM, `dotnet` не подразумевает контактную зону или платформу. Он определяет, что ваш пакет работает на любой платформе, где работают ваши зависимости. При сборке пакета с TxM `dotnet` вы, скорее всего, используете значительно больше зависимостей, связанных с TxM, в вашем `.nuspec`, так как нужно определить пакеты BCL, от которых вы зависите, например `System.Text`, `System.Xml` и т. д. Расположения, где работают эти зависимости, определяют рабочую область вашего пакета.

### <a name="how-do-i-find-out-my-dependencies"></a>Как узнать свои зависимости

Понять, какие зависимости указывать, можно двумя способами:

1. Используйте средство [NuSpec Dependency Generator](https://github.com/onovotny/ReferenceGenerator) **стороннего разработчика**. Оно автоматизирует процесс и обновляет ваш файл `.nuspec` с использованием зависимых пакетов при сборке. Это средство доступно в виде пакета NuGet [NuSpec.ReferenceGenerator](https://www.nuget.org/packages/NuSpec.ReferenceGenerator/).

1. Используйте `ILDasm` для просмотра вашей `.dll`, чтобы узнать, какие сборки действительно нужны во время выполнения (для тех, кто не ищет легких путей). После этого определите, к какому пакету NuGet относится каждая из них.

Дополнительные сведения о функциях, которые помогают создавать пакеты, поддерживающие TxM `dotnet`, см .в разделе [`project.json`](project-json.md).

> [!Important]
> Если ваш пакет предназначен для работы с проектами PCL, настоятельно рекомендуется создать папку `dotnet`, чтобы избежать предупреждений и потенциальных проблем совместимости.

## <a name="directory-structure"></a>Структура каталогов

Пакеты NuGet, использующие этот формат, имеют следующие стандартные папки и поведения:

| Папка | поведения |
| --- | --- |
| Построение | Файлы свойств и целевых объектов MSBuild в этой папке интегрируются в проект по-разному, в противном случае изменения отсутствуют. |
| Инструменты | `install.ps1` и `uninstall.ps1` не выполняются. `init.ps1` работает обычным образом. |
| Content | Содержимое не копируется в проект пользователя автоматически. Поддержка для включения содержимого в проект запланирована в будущих выпусках. |
| LIB | Для множества пакетов `lib` работает так же, как и в NuGet 2.x, но для нее были расширены варианты имен, которые можно использовать внутри этой папки, а также доработана логика для выбора подходящей вложенной папки при использовании пакетов. Однако при использовании в сочетании с `ref` папка `lib` содержит сборки, реализующие контактную зону, которая определяется сборками в папке `ref`. |
| Ссылочный | `ref` — это необязательная папка, которая содержит сборки .NET, определяющие общедоступную область (общие типы и методы), используемую при компиляции приложения. Сборки в этой папке могут не иметь реализации, они используются исключительно в целях определения контактной зоны для компилятора. Если пакет не содержит папку `ref`, то `lib` является как базовой сборкой, так и сборкой реализации. |
| Runtimes | `runtimes` — это необязательная папка, которая содержит код для операционной системы, например для архитектуры ЦП и зависящих от операционной системы или платформы двоичных файлов. |

## <a name="msbuild-targets-and-props-files-in-packages"></a>Файлы целевых объектов и свойств MSBuild в пакетах

Пакеты NuGet могут содержать файлы `.targets` и `.props` файлов, которые импортируются в любой проект MSBuild, где устанавливается пакет. В NuGet 2.x это осуществлялось путем внедрения операторов `<Import>` в файл `.csproj`, в NuGet 3.0 конкретное действие по установке в проект отсутствует. Вместо этого процесс восстановления пакета записывает два файла — `[projectname].nuget.props` и `[projectname].NuGet.targets`.

MSBuild ищет эти файлы и автоматически импортирует их в начале и в конце процесса сборки проекта. Это поведение во многом аналогично NuGet 2.x, но одно из основных отличий заключается в том, что *в этом случае отсутствует гарантированный порядок файлов целевых объектов и свойств*. Однако MSBuild позволяет упорядочить целевые объекты с помощью атрибутов `BeforeTargets` и `AfterTargets` определения `<Target>` (см. раздел [Элемент Target (MSBuild)](/visualstudio/msbuild/target-element-msbuild).

## <a name="lib-and-ref"></a>Lib и Ref

В NuGet 3 поведение папки `lib` изменилось мало. Однако все сборки должны находиться во вложенных папках, названных согласно TxM, и больше не могут находиться прямо в папке `lib`. TxM — это название платформы, с которой должен работать заданный ресурс в пакете. Логически это расширение моникеров целевой платформы (TFM), например `net45`, `net46`, `netcore50` и `dnxcore50` являются примерами TxM (см. раздел [Целевые платформы](../reference/target-frameworks.md). TxM может ссылаться на платформу (TFM), а также на другие контактные зоны конкретных платформ. Например, TxM UWP (`uap10.0`) представляет контактную зону .NET, а также контактную зону Windows для приложений UWP.

Пример структуры lib:

```
lib
├───net40
│       MyLibrary.dll
└───wp81
        MyLibrary.dll
```

Папка `lib` содержит сборки, используемые во время выполнения. Для большинства пакетов для каждого из целевых TxM требуется только папка в `lib`.

## <a name="ref"></a>Ссылочный

Иногда во время компиляции требуется использовать другую сборку (сейчас за это отвечают базовые сборки .NET). В этих случаях используйте папку верхнего уровня с именем `ref` (сокращенное обозначение базовых сборок).

Большинству создателей пакетов папка `ref` не требуется. Она удобна для пакетов, которые должны обеспечивать согласованную контактную зону для компиляции и IntelliSense, однако имеют разные реализации разных TxM. Основным ее вариантом использования являются пакеты `System.*`, создаваемые в процессе доставки .NET Core в NuGet. Они имеют различные реализации, которые унифицируются с помощью согласованного набора базовых сборок.

Технически включенные в папку `ref` сборки — это базовые сборки, передаваемые компилятору. Для тех, кто использовал csc.exe, это сборки, которые мы передаем в параметр [/reference C#](/dotnet/articles/csharp/language-reference/compiler-options/reference-compiler-option).

Структура папки `ref` аналогична `lib`, например:

```
└───MyImageProcessingLib
        ├───lib
        │   ├───net40
        │   │       MyImageProcessingLibrary.dll
        │   │
        │   ├───net451
        │   │       MyImageProcessingLibrary.dll
        │   │
        │   └───win81
        │           MyImageProcessingLibrary.dll
        │
        └───ref
            ├───net40
            │       MyImageProcessingLibrary.dll
            │
            └───portable-net451-win81
                    MyImageProcessingLibrary.dll
```

Здесь все сборки в каталогах `ref` были бы одинаковыми.

## <a name="runtimes"></a>Runtimes

Папка "runtimes" содержит сборки и собственные библиотеки, необходимые для запуска в конкретных средах выполнения, которые обычно определяются операционной системой и архитектурой ЦП. Эти среды выполнения описываются [идентификаторами среды выполнения (RID)](/dotnet/core/rid-catalog), такими как `win`, `win-x86`, `win7-x86`, `win8-64` и т. д.

## <a name="native-helpers-to-use-platform-specific-apis"></a>Собственные вспомогательные приложения для использования API, предназначенных для определенной платформы

В следующем примере показан пакет, имеющий реализацию только из управляемого кода для нескольких платформ, но использующий собственные вспомогательные приложения в Windows 8, где он может вызывать собственные API для Windows 8.

```
└───MyLibrary
        ├───lib
        │   └───net40
        │           MyLibrary.dll
        │
        └───runtimes
            ├───win8-x64
            │   ├───lib
            │   │   └───net40
            │   │           MyLibrary.dll
            │   │
            │   └───native
            │           MyNativeLibrary.dll
            │
            └───win8-x86
                ├───lib
                │   └───net40
                │           MyLibrary.dll
                │
                └───native
                        MyNativeLibrary.dll
```

Для указанного выше пакета выполняется следующее:

- Если работа ведется не в Windows 8, используется сборка `lib/net40/MyLibrary.dll`.

- Если работа ведется в Windows 8, используется `runtimes/win8-<architecture>/lib/MyLibrary.dll`, а `native/MyNativeHelper.dll` копируется в выходные данные сборки.

В приведенном выше примере сборка `lib/net40` состоит исключительно из управляемого кода, а сборки в папке "runtimes" будут вызывать неуправляемый код для сборки собственного вспомогательного приложения, чтобы вызвать API, относящиеся к Windows 8.

Вы можете выбрать только одну папку `lib`, поэтому при наличии конкретной папки для среды выполнения выбирается именно она вместо папки `lib`, не относящейся ни к какой среде. Собственная папка является аддитивной, при ее наличии она копируется в выходные данные сборки.

## <a name="managed-wrapper"></a>Управляемая оболочка

Другой способ использования среды выполнения заключается в поставке пакета, который представляет собой оболочку, состоящую исключительно из управляемого кода, вместо сборки в машинном коде. В этом сценарии вы создаете следующий пакет:

```
└───MyLibrary
        └───runtimes
            ├───win8-x64
            │   ├───lib
            │   │   └───net451
            │   │           MyLibrary.dll
            │   │
            │   └───native
            │           MyImplementation.dll
            │
            └───win8-x86
                ├───lib
                │   └───net451
                │           MyLibrary.dll
                │
                └───native
                        MyImplementation.dll
```

Здесь папка верхнего уровня `lib` отсутствует, так как нет реализации этого пакета, которая не зависит от соответствующей машинной сборки. Если бы управляемая сборка `MyLibrary.dll` была одинаковой в обоих случаях, можно было бы поместить ее в папку `lib` верхнего уровня, но из-за отсутствия машинной сборки не возникает ошибка при установке пакета на платформе, отличной от win-x86 и win-x64, а также использовалась бы папка "lib" верхнего уровня, однако машинная сборка не копировалась бы.

## <a name="authoring-packages-for-nuget-2-and-nuget-3"></a>Создание пакетов для NuGet 2 и NuGet 3

Если вы хотите создать пакет, который могут использовать проекты, использующие `packages.config`, а также пакеты, использующие `project.json`, применяются следующие условия:

- Папки "ref" и "runtimes" работают только в NuGet 3. В NuGet 2 обе они игнорируются.

- Невозможно полагаться на работу `install.ps1` или `uninstall.ps1`. Эти файлы выполняются при использовании `packages.config`, однако игнорируются при `project.json`. Поэтому пакет должен работать без них. `init.ps1` по-прежнему выполняется на NuGet 3.

- Установка целевых объектов и свойств отличается, поэтому убедитесь, что ваш пакет работает правильно для обоих клиентов.

- Подкаталоги папки "lib" должны быть TxM в NuGet 3. Невозможно поместить библиотеки в корень папки `lib`.

- При использовании NuGet 3 содержимое не копируется автоматически. Потребители вашего пакета могут скопировать файлы самостоятельно или воспользоваться таким средством, как запускатель задач, чтобы автоматизировать этот процесс.

- NuGet 3 не преобразует файлы конфигурации и исходного кода.

Если вы поддерживаете NuGet 2 и 3, то `minClientVersion` должен соответствовать самой ранней версии клиента NuGet 2, с которой работает ваш пакет. При использовании существующего пакета изменять его не требуется.
