---
title: Заметки о выпуске NuGet 2,1
description: Заметки о выпуске NuGet 2,1, включая известные проблемы, исправления ошибок, добавленные функции и DCR.
author: JonDouglas
ms.author: jodou
ms.date: 11/11/2016
ms.topic: conceptual
ms.openlocfilehash: c44ad32c8c4018ccb517b41bffda674eef1f11f3
ms.sourcegitcommit: ee6c3f203648a5561c809db54ebeb1d0f0598b68
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/26/2021
ms.locfileid: "98777025"
---
# <a name="nuget-21-release-notes"></a>Заметки о выпуске NuGet 2,1

[Заметки о](../release-notes/nuget-2.0.md)  |  выпуске NuGet 2,0 [Заметки о выпуске NuGet 2,2](../release-notes/nuget-2.2.md)

Версия NuGet 2,1 была выпущена 4 октября 2012 г.

## <a name="hierarchical-nugetconfig"></a>Иерархическая Nuget.Config

NuGet 2,1 предоставляет большую гибкость в управлении параметрами NuGet с помощью рекурсивного прохода по структуре папок для поиска `NuGet.Config` файлов и последующей сборки конфигурации из набора всех найденных файлов.  В качестве примера рассмотрим ситуацию, когда у команды есть внутренний репозиторий пакетов для CI-сборок других внутренних зависимостей. Структура папок для отдельного проекта может выглядеть следующим образом:

```
C:\
C:\myteam\
C:\myteam\solution1
C:\myteam\solution1\project1
```

Кроме того, если для решения включено восстановление пакетов, будет также существовать Следующая папка:

```
C:\myteam\solution1\.nuget
```

Чтобы обеспечить доступность внутреннего репозитория пакетов для всех проектов, над которыми работает команда, не делая ее доступной для каждого проекта на компьютере, можно создать новый файл Nuget.Config и поместить его в папку к:\митеам. Для каждого проекта невозможно выполнить конкретную папку пакетов.

```xml
<configuration>
    <packageSources>
    <add key="Official project team source" value="http://teamserver/api/v2/" />
    </packageSources>
    <disabledPackageSources />
    <activePackageSource>
    <add key="Official project team source" value="http://teamserver/api/v2/" />
    </activePackageSource>
</configuration>
```

Теперь можно увидеть, что источник добавлен, запустив команду "nuget.exe источники" из любой папки под к:\митеам, как показано ниже:

![Источники пакетов из родительской конфигурации NuGet](./media/releasenotes-21-cfg-hierarchy.png)

`NuGet.Config` Поиск файлов выполняется в следующем порядке:

1. `.nuget\Nuget.Config`
2. Рекурсивный обход из папки проекта в корневую папку
3. Global `Nuget.Config` ( `%appdata%\NuGet\Nuget.Config` )

Конфигурации применяются в *обратном порядке*, то есть в соответствии с приведенным выше порядком, сначала применяется Глобальная Nuget.Config, а затем обнаруженные Nuget.Config файлы из корневой папки в папку проекта, а затем `.nuget\Nuget.Config` .  Это особенно важно, если вы используете `<clear/>` элемент для удаления набора элементов из конфигурации.

## <a name="specify-packages-folder-location"></a>Укажите расположение папки "Packages"

В прошлом NuGet управляет пакетами решения из известной папки Packages, найденной в корневой папке решения.  Для команд разработчиков, имеющих множество различных решений, на которых установлены пакеты NuGet, это может привести к установке одного и того же пакета во многих разных местах файловой системы.

NuGet 2,1 обеспечивает более детальный контроль расположения папки Packages с помощью `repositoryPath` элемента в `NuGet.Config` файле.  Основываясь на предыдущем примере поддержки иерархических Nuget.Config, предположим, что нам нужно, чтобы все проекты в К:\митеам\ использовали одну и ту же папку пакетов.  Для этого просто добавьте следующую запись в `c:\myteam\Nuget.Config` .

```xml
<configuration>
    <config>
    <add key="repositoryPath" value="C:\myteam\teampackages" />
    </config>
    ...
</configuration>
```

В этом примере общий `Nuget.Config` файл указывает общую папку пакетов для каждого проекта, созданного под к:\митеам, независимо от глубины. Обратите внимание, что если у вас есть папка Packages под корнем решения, необходимо удалить ее, прежде чем NuGet поместит пакеты в новое расположение.

## <a name="support-for-portable-libraries"></a>Поддержка переносимых библиотек

[Переносимые библиотеки](/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library) — это функция, впервые появившаяся в .NET 4, которая позволяет создавать сборки, которые могут работать без изменений на разных платформах Майкрософт, от версий The.NET Framework до Silverlight для Windows Phone и даже Xbox 360 (хотя в настоящее время NuGet не поддерживает целевой объект переносимой библиотеки Xbox).  Расширяя [соглашения о пакетах](../create-packages/supporting-multiple-target-frameworks.md) для версий и профилей платформы, NuGet 2,1 теперь поддерживает переносимые библиотеки, позволяя создавать пакеты с составными папками платформы и целевого профиля `lib` .

В качестве примера рассмотрим следующие доступные целевые платформы переносимой библиотеки классов.

![Диалоговое окно создания переносимой библиотеки](./media/releasenotes-21-plib.png)

После сборки библиотеки и `nuget.exe pack MyPortableProject.csproj` выполнения команды можно просмотреть новую структуру папок пакета переносимой библиотеки, изучив содержимое созданного пакета NuGet.

![Макет переносимого пакета библиотеки](./media/releasenotes-21-plib-layout.png)

Как видите, соглашение о имени папки переносимой библиотеки соответствует шаблону "Portable-{Framework 1} + {Framework n}", где идентификаторы платформы соответствуют [соглашениям о существующем имени и версии платформы](../reference/target-frameworks.md). Одно исключение из соглашений об имени и версии находится в идентификаторе платформы, используемом для Windows Phone.  В этом моникере следует использовать имя платформы "WP" (WP7, wp71 или WP8). Например, использование "Silverlight-WP7" приведет к ошибке.

При установке пакета, созданного из этой структуры папок, NuGet теперь может применять свои платформы и правила профилей к нескольким целевым объектам, как указано в имени папки.  Правила сопоставления NuGet являются принципом того, что "более конкретные" целевые объекты имеют приоритет над "менее конкретными".  Это означает, что моникеры, предназначенные для конкретной платформы, всегда будут предпочтительнее, чем переносимые, если они совместимы с проектом.  Кроме того, если несколько переносимых целевых объектов совместимы с проектом, NuGet будет предпочитать, что набор поддерживаемых платформ является ближайшим к проекту, ссылающимся на пакет.

## <a name="targeting-windows-8-and-windows-phone-8-projects"></a>Нацеливание на проекты Windows 8 и Windows Phone 8

Помимо добавления поддержки для проектов с переносимыми библиотеками, NuGet 2,1 предоставляет новые моникеры платформы для Магазина Windows 8 и Windows Phone 8, а также некоторые новые общие моникеры для проектов Магазина Windows и Windows Phone, которые проще всего управлять в будущих версиях соответствующих платформ.

Для приложений Магазина Windows 8 идентификаторы выглядят следующим образом:

| NuGet 2,0 и более ранних версий | NuGet 2.1 |
| ---------------- | ----------- |
| winRT45, . NETCore45 | Windows, Windows8, Win, Win8 |

<br/>
Для проектов Windows Phone идентификаторы выглядят следующим образом:

| Телефонная ОС | NuGet 2,0 и более ранних версий | NuGet 2.1 |
| --- | --- | --- |
| Windows Phone 7 | Silverlight3-WP | WP, WP7, WindowsPhone, WindowsPhone7 |
| Windows Phone 7,5 (с) | silverlight4-wp71 | wp71, WindowsPhone71 |
| Windows Phone 8 | (Не поддерживается) | WP8, WindowsPhone8 |

<br/>
Во всех перечисленных выше изменениях старые имена платформ будут по прежнему поддерживаться в NuGet 2,1.  При перемещении вперед используются новые имена, так как они будут более стабильными в будущих версиях соответствующих платформ. Новые имена *не* будут поддерживаться в версиях NuGet до 2,1, поэтому необходимо соответствующим образом спланировать, когда следует использовать параметр.

## <a name="improved-search-in-package-manager-dialog"></a>Улучшенный поиск в диалоговом окне диспетчера пакетов

За последние несколько итераций появились изменения в коллекции NuGet, которые значительно улучшили скорость и релевантность поиска пакетов.  Однако эти улучшения были ограничены веб-сайтом nuget.org.  NuGet 2,1 делает Улучшенный интерфейс поиска доступным в диалоговом окне диспетчера пакетов NuGet.  В качестве примера представьте, что вы хотели бы найти пакет предварительной версии Windows Azure Caching.  Разумный поисковый запрос для этого пакета может быть "кэшем Azure".  В предыдущих версиях диалогового окна Диспетчер пакетов нужный пакет даже не был указан на первой странице результатов.  Однако в NuGet 2,1 требуемый пакет теперь отображается в верхней части результатов поиска.

![Поиск в диалоговом окне диспетчера пакетов](./media/releasenotes-21-vsdlg-search.png)

## <a name="force-package-update"></a>Принудительное обновление пакета

До NuGet 2,1 NuGet пропустит обновление пакета, если не был задан старший номер версии.  Это сделало трение для определенных сценариев, особенно в случае сценариев сборки или CI, в которых команде не нужно увеличивать номер версии пакета при каждой сборке.  Требуемое поведение заключается в принудительном обновлении без учета.  NuGet 2,1 обращается к этому параметру с флагом "REINSTALL".  Например, предыдущие версии NuGet приведут к следующим результатам при попытке обновить пакет, для которого не была установлена более поздняя версия пакета:

```
PM> Update-Package Moq
No updates available for 'Moq' in project 'MySolution.MyConsole'.
```

При использовании флага переустановки пакет будет обновлен независимо от наличия более новой версии.

```
PM> Update-Package Moq -Reinstall
Successfully removed 'Moq 4.0.10827' from MySolution.MyConsole.
Successfully uninstalled 'Moq 4.0.10827'.
Successfully installed 'Moq 4.0.10827'.
Successfully added 'Moq 4.0.10827' to MySolution.MyConsole.
```

Другой сценарий, в котором флаг переустановки подтверждает преимущества, заключается в том, что платформа перенацелена на платформу. При изменении целевой платформы проекта (например, с .NET 4 на .NET 4,5) Update-Package-REINSTALL может обновить ссылки на правильные сборки для всех пакетов NuGet, установленных в проекте.

## <a name="edit-package-sources-within-visual-studio"></a>Изменение источников пакетов в Visual Studio

В предыдущих версиях NuGet обновление источника пакета в диалоговом окне "Параметры Visual Studio" требовало удаления и повторного добавления источника пакета.  NuGet 2,1 улучшает этот рабочий процесс, поддерживая обновление как функцию первого класса пользовательского интерфейса конфигурации.

![Диалоговое окно настройки диспетчера пакетов](./media/releasenotes-21-edit-pkg-source.png)

## <a name="bug-fixes"></a>Исправления ошибок

NuGet 2,1 включает множество исправлений ошибок. Полный список рабочих элементов, исправленных в NuGet 2,0, см. в [этом выпуске](http://nuget.codeplex.com/workitem/list/advanced?keyword=&status=Fixed&type=All&priority=All&release=NuGet%202.1&assignedTo=All&component=All&sortField=LastUpdatedDate&sortDirection=Descending&page=0).
