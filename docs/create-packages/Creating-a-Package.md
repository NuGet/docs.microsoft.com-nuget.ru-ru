---
title: Создание пакета NuGet с помощью CLI nuget.exe
description: Подробное руководство по проектированию и созданию пакета NuGet, включая принятие решений по ключевым аспектам, таким как файлы и управление версиями.
author: karann-msft
ms.author: karann
ms.date: 07/09/2019
ms.topic: conceptual
ms.openlocfilehash: b3e6f0efc9e2e12de186ffd4ce29d496d07d5fc4
ms.sourcegitcommit: c81561e93a7be467c1983d639158d4e3dc25b93a
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/02/2020
ms.locfileid: "78230958"
---
# <a name="create-a-package-using-the-nugetexe-cli"></a>Создание пакета с помощью CLI nuget.exe

Независимо от назначения вашего пакета или содержащегося в нем кода, с помощью одного из средств CLI (`nuget.exe` или `dotnet.exe`) вы можете создать компонент, которым можно поделиться с любым количеством разработчиков для совместного использования. Инструкции по установке средств CLI для NuGet см. в статье [Установка клиентских средств NuGet](../install-nuget-client-tools.md). Обратите внимание на то, что средство CLI не входит в состав Visual Studio по умолчанию.

- Чтобы создать пакет для проектов в другом стиле (например, для проектов .NET Framework) выполните шаги, описанные в этой статье. Пошаговые инструкции по использованию Visual Studio и CLI `nuget.exe` см. в руководстве по [созданию и публикации пакета .NET Framework](../quickstart/create-and-publish-a-package-using-visual-studio-net-framework.md).

- См. подробнее о проектах .NET Core и .NET Standard [не на основе пакетов SDK](../resources/check-project-format.md) и других проектах на основе пакетов SDK в руководстве по [созданию пакета NuGet с помощью CLI dotnet](creating-a-package-dotnet-cli.md).

- Для проектов, перенесенных из `packages.config` в [PackageReference](../consume-packages/package-references-in-project-files.md), используйте [msbuild -t:pack](../consume-packages/migrate-packages-config-to-package-reference.md#create-a-package-after-migration).

С технической точки зрения, пакет NuGet — это просто ZIP-файл, расширение которого изменено на `.nupkg` и содержимое которого соответствует определенным соглашениям. В этом разделе подробно описывается создание пакета, в котором соблюдаются эти соглашения.

Создание пакета начинается с подготовки скомпилированного кода (сборок), символов и других файлов, которые должны быть включены в пакет (см. раздел [Процесс создания пакета](overview-and-workflow.md)). Этот процесс не зависит от компиляции и других задач по созданию файлов для пакета, хотя вы можете использовать информацию из файла проекта для синхронизации скомпилированных сборок и пакетов.

> [!Important]
> Эта статья применяется к проектам со стилем, отличным от пакетов SDK, то есть не таких как проекты .NET Core и .NET Standard, для которых используются Visual Studio 2017 и NuGet 4.0 и более поздних версий.

## <a name="decide-which-assemblies-to-package"></a>Выбор сборок для добавления в пакет

Большинство пакетов общего назначения содержат одну или несколько сборок, которые другие разработчики могут использовать в собственных проектах.

- Как правило, для каждой сборки лучше создавать собственный пакет NuGet, если эти сборки используются независимо. Например, если есть сборка `Utilities.dll`, которая зависит от сборки `Parser.dll`, но сборка `Parser.dll` также полезна сама по себе, создайте для каждой из этих сборок отдельный пакет. Это позволит разработчикам использовать `Parser.dll` независимо от `Utilities.dll`.

- Если библиотека состоит из нескольких сборок, которые не используются сами по себе, то их предпочтительнее объединить в одном пакете. В продолжение предыдущего примера, если сборка `Parser.dll` содержит код, который используется только сборкой `Utilities.dll`, то сборку `Parser.dll` лучше включить в тот же пакет.

- Аналогичным образом, если сборка `Utilities.dll` зависит от сборки `Utilities.resources.dll`, которая не используется сама по себе, включите их в один пакет.

Ресурсы представляют собой особый случай. Когда пакет устанавливается в проекте, NuGet автоматически добавляет ссылки на библиотеки DLL сборок в пакете, *кроме* тех из них, в именах которых есть `.resources.dll`, так как они считаются локализованными вспомогательными сборками (см. раздел [Создание локализованных пакетов](creating-localized-packages.md)). По этой причине следует избегать использования `.resources.dll` в именах файлов пакета, которые содержат важный код.

Если библиотека содержит сборки COM-взаимодействия, следуйте дополнительным указаниям в разделе [Создание пакетов, содержащих сборки COM-взаимодействия](author-packages-with-com-interop-assemblies.md).

## <a name="the-role-and-structure-of-the-nuspec-file"></a>Назначение и структура файла NUSPEC

После того как вы решите, какие файлы нужно включить в пакет, следует создать манифест пакета в XML-файле `.nuspec`.

Манифест служит следующим целям:

1. Описывает содержимое пакета и сам включается в него.
1. Управляет созданием пакета и предоставляет диспетчеру NuGet указания по установке пакета в проекте. Например, в манифесте определяются другие зависимости пакета, чтобы диспетчер NuGet мог также установить их при установке основного пакета.
1. Содержит обязательные и необязательные свойства, как описано ниже. Полные сведения, включая описание свойств, которые не упомянуты в этом разделе, см. в [справочнике по файлам NUSPEC](../reference/nuspec.md).

Обязательные свойства:

- идентификатор пакета, который должен быть уникальным в пределах коллекции, содержащей пакет;
- определенный номер версии в формате *основной_номер.дополнительный_номер.исправление[-суффикс]* , где *-суффикс* указывает на [предварительные версии](prerelease-packages.md);
- название пакета, которое должно отображаться на сайте размещения (например, nuget.org);
- сведения об авторе и владельце;
- подробное описание пакета.

Часто используемые необязательные свойства:

- заметки о выпуске;
- сведения об авторских правах;
- краткое описание для [пользовательского интерфейса диспетчера пакетов в Visual Studio](../consume-packages/install-use-packages-visual-studio.md);
- код языка;
- URL проекта
- лицензия в виде выражения или файла (`licenseUrl` скоро станет нерекомендуемым, используйте [nuspec-элемент метаданных `license`](../reference/nuspec.md#license));
- URL-адрес значка;
- список зависимостей и ссылок;
- теги, упрощающие поиск в коллекции.

Ниже приведен типичный (но вымышленный) файл `.nuspec` с комментариями, описывающими свойства.

```xml
<?xml version="1.0"?>
<package xmlns="http://schemas.microsoft.com/packaging/2010/07/nuspec.xsd">
    <metadata>
        <!-- The identifier that must be unique within the hosting gallery -->
        <id>Contoso.Utility.UsefulStuff</id>

        <!-- The package version number that is used when resolving dependencies -->
        <version>1.8.3-beta</version>

        <!-- Authors contain text that appears directly on the gallery -->
        <authors>Dejana Tesic, Rajeev Dey</authors>

        <!-- 
            Owners are typically nuget.org identities that allow gallery
            users to easily find other packages by the same owners.  
        -->
        <owners>dejanatc, rjdey</owners>
        
         <!-- Project URL provides a link for the gallery -->
        <projectUrl>http://github.com/contoso/UsefulStuff</projectUrl>

         <!-- License information is displayed on the gallery -->
        <license type="expression">Apache-2.0</license>
        

        <!-- The icon is used in Visual Studio's package manager UI -->
        <iconUrl>http://github.com/contoso/UsefulStuff/nuget_icon.png</iconUrl>

        <!-- 
            If true, this value prompts the user to accept the license when
            installing the package. 
        -->
        <requireLicenseAcceptance>false</requireLicenseAcceptance>

        <!-- Any details about this particular release -->
        <releaseNotes>Bug fixes and performance improvements</releaseNotes>

        <!-- 
            The description can be used in package manager UI. Note that the
            nuget.org gallery uses information you add in the portal. 
        -->
        <description>Core utility functions for web applications</description>

        <!-- Copyright information -->
        <copyright>Copyright ©2016 Contoso Corporation</copyright>

        <!-- Tags appear in the gallery and can be used for tag searches -->
        <tags>web utility http json url parsing</tags>

        <!-- Dependencies are automatically installed when the package is installed -->
        <dependencies>
            <dependency id="Newtonsoft.Json" version="9.0" />
        </dependencies>
    </metadata>

    <!-- A readme.txt to display when the package is installed -->
    <files>
        <file src="readme.txt" target="" />
    </files>
</package>
```

Подробные сведения об объявлении зависимостей и указании номеров версий см. в разделе [packages.config](../reference/packages-config.md) и [Управление версиями пакета](../concepts/package-versioning.md). Доступ к ресурсам зависимостей в пакете можно также предоставлять напрямую с помощью атрибутов `include` и `exclude` элемента `dependency`. См. подраздел "Зависимости" в разделе [Справочник по файлам NUSPEC](../reference/nuspec.md#dependencies).

Так как манифест включается в пакет, создаваемый на его основе, вы можете получить дополнительные примеры, изучив существующие пакеты. Хорошим их источником может служить папка *global-packages* на компьютере, расположение которой можно получить с помощью следующей команды:

```cli
nuget locals -list global-packages
```

Перейдите в любую папку *пакет\версия*, скопируйте файл `.nupkg` в файл `.zip`, затем откройте этот файл `.zip` и изучите содержимое файла `.nuspec` в нем.

> [!Note]
> При создании файла `.nuspec` из проекта Visual Studio манифест содержит токены, которые заменяются сведениями из проекта при сборке пакета. См. раздел [Создание файла NUSPEC на основе проекта Visual Studio](#from-a-visual-studio-project).

## <a name="create-the-nuspec-file"></a>Создание NUSPEC-файла

Создание полного манифеста, как правило, начинается с базового файла `.nuspec`, который создается одним из следующих способов на основе:

- [рабочего каталога, соответствующего соглашениям](#from-a-convention-based-working-directory);
- [библиотеки DLL сборки](#from-an-assembly-dll);
- [проекта Visual Studio](#from-a-visual-studio-project);    
- [нового файла со значениями по умолчанию](#new-file-with-default-values).

Затем нужно отредактировать файл вручную так, чтобы он описывал содержимое итогового пакета.

> [!Important]
> Автоматически формируемые файлы `.nuspec` содержат заполнители, которые нужно изменить перед созданием пакета с помощью команды `nuget pack`. Если файл `.nuspec` содержит заполнители, эта команда завершается сбоем.

### <a name="from-a-convention-based-working-directory"></a>На основе рабочего каталога, соответствующего соглашениям

Так как пакет NuGet — это просто ZIP-файл, расширение которого изменено на `.nupkg`, зачастую проще всего создать нужную структуру папок в локальной файловой системе, а затем создать файл `.nuspec` на основе этой структуры. Команда `nuget pack` автоматически добавляет все файлы, имеющиеся в этой структуре папок (кроме папок, начинающихся с `.`, что позволяет иметь закрытые файлы в этой же структуре).

Преимущество такого подхода в том, что вам не нужно указывать в манифесте файлы, которые требуется включить в пакет (как описано далее в этом разделе). В процессе сборки можно создать структуру папок, которая будет в точности перенесена в пакет, и легко включить в него другие файлы, которые в противном случае не были бы добавлены в проект:

- содержимое и исходный код, которые следует внедрить в конечный проект;
- Сценарии PowerShell
- преобразования существующих файлов конфигурации и исходного кода в проекте.

Ниже представлены соглашения в отношении папок.

| Папка | Описание | Действие при установке пакета |
| --- | --- | --- |
| (корневая) | Расположение файла readme.txt | При установке пакета в Visual Studio отображается файл readme.txt в корневой папке проекта. |
| lib/{tfm} | Файлы сборки (`.dll`), документации (`.xml`) и символов (`.pdb`) для данного моникера целевой платформы (TFM) | Сборки добавляются как ссылки для использования во время компиляции или выполнения. Файлы `.xml` и `.pdb` копируются в папки проекта. Сведения о создании вложенных папок для определенных целевых платформ см. в разделе [Поддержка нескольких целевых платформ](supporting-multiple-target-frameworks.md). |
| ref/{tfm} | Файлы сборки (`.dll`) и символов (`.pdb`) для определенного моникера целевой платформы (TFM) | Сборки добавляются как ссылки для использования только во время компиляции. Поэтому в папку bin проекта ничего не копируется. |
| runtimes | Файлы сборки (`.dll`), символов (`.pdb`) и машинных ресурсов (`.pri`) для определенной архитектуры | Сборки добавляются как ссылки для использования только во время выполнения. Остальные файлы копируются в папки проекта. В папке `/ref/{tfm}` всегда должна быть соответствующая сборка (TFM) для `AnyCPU`, чтобы предоставить соответствующие сборки, используемые во время компиляции. См. раздел [Поддержка нескольких целевых платформ](supporting-multiple-target-frameworks.md). |
| содержание | Произвольные файлы | Содержимое копируется в корневую папку проекта. Папку **content** можно представить как корневую папку целевого приложения, которое будет использовать пакет. Чтобы пакет добавил изображение в папку */images* приложения, поместите это изображение в папку *content/images* пакета. |
| выполнить сборку | Файлы MSBuild `.targets` и `.props` *(3.x+)* . | Автоматическое добавление в проект. |
| buildMultiTargeting | Файлы MSBuild `.targets` и `.props` *(4.0+)* для кроссплатформенного определения. | Автоматическое добавление в проект. |
| buildTransitive | Файлы MSBuild `.targets` и `.props` *(5.0+)* , которые можно транзитивно передавать в любой соответствующий проект. См. об [этой функции](https://github.com/NuGet/Home/wiki/Allow-package--authors-to-define-build-assets-transitive-behavior). | Автоматическое добавление в проект. |
| средства | Скрипты и программы PowerShell, доступные из консоли диспетчера пакетов | Папка `tools` добавляется в переменную среды `PATH` только для консоли диспетчера пакетов (в частности, она *не* добавляется в переменную `PATH` для среды MSBuild при сборке проекта). |

Так как в структуре папок может быть сколько угодно сборок для любого числа целевых платформ, этот метод обязателен при создании пакетов, поддерживающих несколько платформ.

После того как вы подготовите нужную структуру папок, выполните в ней следующую команду, чтобы создать файл `.nuspec`:

```cli
nuget spec
```

Созданный файл `.nuspec` не содержит явных ссылок на файлы в структуре папок. NuGet автоматически включает все файлы при создании пакета. Однако вам необходимо отредактировать значения-заполнители в других частях манифеста.

### <a name="from-an-assembly-dll"></a>На основе библиотеки DLL сборки

В такой простой ситуации, как создание пакета на основе сборки, вы можете создать файл `.nuspec` из содержащихся в сборке метаданных с помощью следующей команды:

```cli
nuget spec <assembly-name>.dll
```

При использовании такого формата ряд заполнителей в манифесте заменяется конкретными значениями из сборки. Например, свойству `<id>` присваивается имя сборки, а свойству `<version>` — ее версия. Однако остальные свойства в манифесте не имеют соответствующих значений в сборке и поэтому по-прежнему содержат заполнители.

### <a name="from-a-visual-studio-project"></a>На основе проекта Visual Studio

Создавать файл `.nuspec` на основе файла `.csproj` или `.vbproj` удобно, так как ссылки на другие пакеты, установленные в проекте, как и на зависимости, создаются автоматически. Просто выполните следующую команду в папке, в которой находится файл проекта:

```cli
# Use in a folder containing a project file <project-name>.csproj or <project-name>.vbproj
nuget spec
```

Получившийся файл `<project-name>.nuspec` содержит *токены*, которые заменяются во время создания пакета значениями их проекта, включая ссылки на другие пакеты, которые уже установлены.

Если у вас есть зависимости пакетов для включения в файл *.nuspec*, используйте вместо этого `nuget pack` и получите файл *.nuspec* из созданного файла *.nupkg*. Например, используйте следующую команду.

```cli
# Use in a folder containing a project file <project-name>.csproj or <project-name>.vbproj
nuget pack myproject.csproj
```

Токен отделяется символами `$` с обеих сторон свойства проекта. Например, значение `<id>` в созданном таким образом манифесте, как правило, имеет следующий вид:

```xml
<id>$id$</id>
```

Этот токен заменяется значением `AssemblyName` из файла проекта во время упаковки. Точные сведения о том, как значения из проекта сопоставляются с токенами `.nuspec`, см. в [справочнике по токенам замены](../reference/nuspec.md#replacement-tokens).

Токены избавляют от необходимости изменять критически важные значения, такие как номер версии, в файле `.nuspec` при обновлении пакета. (При необходимости токены всегда можно заменить на конкретные значения.) 

Обратите внимание на то, что при работе с проектом Visual Studio доступно несколько дополнительных параметров создания пакета, которые описываются далее в подразделе [Выполнение команды nuget pack для создания файла NUPKG](#run-nuget-pack-to-generate-the-nupkg-file).

#### <a name="solution-level-packages"></a>Пакеты на уровне решения

*Только в NuGet 2.x. Недоступно в NuGet 3.0 и более поздних версиях.*

В NuGet 2.x поддерживалась концепция пакетов на уровне решения, которые устанавливают средства или дополнительные команды для консоли диспетчера команд (содержимое папки `tools`), но не добавляют ссылки, содержимое или настройки сборки в проекты решения. Такие пакеты не содержат файлов непосредственно в папках `lib`, `content` или `build`, а их зависимости не содержат файлов в соответствующих папках `lib`, `content` или `build`.

NuGet отслеживает установленные пакеты уровня решения в файле `packages.config` в папке `.nuget`, а не в файле `packages.config` проекта.

### <a name="new-file-with-default-values"></a>Новый файл со значениями по умолчанию

Следующая команда создает манифест по умолчанию с заполнителями, формируя надлежащую структуру файлов:

```cli
nuget spec [<package-name>]
```

Если не указать параметр \<package-name\>, получившийся файл будет иметь имя `Package.nuspec`. Если указать имя, например `Contoso.Utility.UsefulStuff`, файл будет иметь имя `Contoso.Utility.UsefulStuff.nuspec`.

Полученный файл `.nuspec` содержит заполнители для значений, например `projectUrl`. Прежде чем использовать этот файл для создания итогового файла `.nupkg`, его необходимо отредактировать.

## <a name="choose-a-unique-package-identifier-and-setting-the-version-number"></a>Выбор уникального идентификатора пакета и задание номера версии

Идентификатор пакета (элемент `<id>`) и номер версии (элемент `<version>`) — два самых важных значения в манифесте, так как они однозначно определяют код, содержащийся в пакете.

**Рекомендации в отношении идентификатора пакета**

- **Уникальность**. Идентификатор должен быть уникальным в пределах nuget.org или другой коллекции, в которой размещается пакет. Прежде чем задавать идентификатор, проверьте, не используется ли оно уже в соответствующей коллекции. Во избежание конфликтов рекомендуется использовать в качестве первой части идентификатора название организации, например `Contoso.`.
- **Имена в стиле пространств имен**. Используйте шаблон, по которому строятся имена пространств имен в .NET, используя нотацию с точками, а не с дефисами. Например, используйте идентификатор `Contoso.Utility.UsefulStuff` вместо `Contoso-Utility-UsefulStuff` или `Contoso_Utility_UsefulStuff`. Пользователям также удобно, когда идентификатор пакета соответствует пространствам имен, используемым в коде.
- **Примеры пакетов**. Если вы создаете пакет с примером кода, демонстрирующим использование другого пакета, добавьте к идентификатору суффикс `.Sample`, например `Contoso.Utility.UsefulStuff.Sample`. (Образец пакета, конечно, должен иметь зависимость от другого пакета.) При создании образца пакета используйте описанный выше метод на основе рабочего каталога, соответствующего соглашениям. В папке `content` разместите код образца в папке с именем `\Samples\<identifier>`, например `\Samples\Contoso.Utility.UsefulStuff.Sample`.

**Рекомендации в отношении версии пакета**

- Как правило, версия пакета должна соответствовать версии библиотеки, хотя это не строгое требование. Это легко реализовать, если пакет ограничен единственной сборкой, как было описано выше в подразделе [Выбор сборок для добавления в пакет](#decide-which-assemblies-to-package). В целом помните, что при разрешении зависимостей диспетчер NuGet ориентируется на версии пакетов, а не на версии сборок.
- При применении нестандартной схемы версий обязательно учитывайте правила управления версиями в NuGet, которые изложены в разделе [Управление версиями пакета](../concepts/package-versioning.md).

> Разобраться в принципах управления версиями также может помочь следующая серия коротких записей блога:
>
> - [Часть 1. Решение проблем с DLL](https://blog.davidebbo.com/2011/01/nuget-versioning-part-1-taking-on-dll.html)
> - [Часть 2. Базовый алгоритм](https://blog.davidebbo.com/2011/01/nuget-versioning-part-2-core-algorithm.html)
> - [Часть 3. Унификация путем переадресации привязок](https://blog.davidebbo.com/2011/01/nuget-versioning-part-3-unification-via.html)

## <a name="add-a-readme-and-other-files"></a>Добавление файла сведений и других файлов

Чтобы явным образом указать файлы, которые следует включить в пакет, используйте узел `<files>` в файле `.nuspec`, который находится *после* тега `<metadata>`:

```xml
<?xml version="1.0"?>
<package xmlns="http://schemas.microsoft.com/packaging/2010/07/nuspec.xsd">
    <metadata>
    <!-- ... -->
    </metadata>
    <files>
        <!-- Add a readme -->
        <file src="readme.txt" target="" />

        <!-- Add files from an arbitrary folder that's not necessarily in the project -->
        <file src="..\..\SomeRoot\**\*.*" target="" />
    </files>
</package>
```

> [!Tip]
> При использовании подхода на основе рабочего каталога, соответствующего соглашениям, файл readme.txt можно поместить в корневую папку пакета, а другое содержимое — в папку `content`. Элементы `<file>` в манифесте не требуются.

Если в корневую папку пакета добавлен файл с именем `readme.txt`, Visual Studio отображает содержимое этого файла в виде обычного текста сразу после установки пакета напрямую. (Файлы сведений не отображаются для пакетов, устанавливаемых как зависимости.) Например, вот как выглядит файл сведений для пакета HtmlAgilityPack:

![Отображение файла сведений для пакета NuGet при установке](media/Create_01-ShowReadme.png)

> [!Note]
> Если узел `<files>` в файле `.nuspec` пуст, NuGet включает в пакет только содержимое из папки `lib`.

## <a name="include-msbuild-props-and-targets-in-a-package"></a>Включение в пакет свойств и целей MSBuild

В некоторых случаях в проекты, использующие пакет, необходимо добавить пользовательские целевые объекты сборки или свойства, например, если во время сборки должно запускаться пользовательское средство или процесс. Для этого нужно поместить файлы в формате `<package_id>.targets` или `<package_id>.props` (например, `Contoso.Utility.UsefulStuff.targets`) в папку `\build` проекта.

Файлы в корневой папке `\build` считаются пригодными для всех целевых платформ. Чтобы предоставить файлы для определенных платформ, сначала поместите их в соответствующие вложенные папки, например следующие:

    \build
        \netstandard1.4
            \Contoso.Utility.UsefulStuff.props
            \Contoso.Utility.UsefulStuff.targets
        \net462
            \Contoso.Utility.UsefulStuff.props
            \Contoso.Utility.UsefulStuff.targets

Затем в файле `.nuspec` укажите ссылки на эти файлы в узле `<files>`:

```xml
<?xml version="1.0"?>
<package >
    <metadata minClientVersion="2.5">
    <!-- ... -->
    </metadata>
    <files>
        <!-- Include everything in \build -->
        <file src="build\**" target="build" />

        <!-- Other files -->
        <!-- ... -->
    </files>
</package>
```

Включение свойств и целевых объектов MSBuild в пакет [появилось в NuGet 2.5](../release-notes/NuGet-2.5.md#automatic-import-of-msbuild-targets-and-props-files), поэтому рекомендуется добавить атрибут `minClientVersion="2.5"` в элемент `metadata`, чтобы указать минимальную версию клиента NuGet, необходимую для использования пакета.

Когда NuGet устанавливает пакет с `\build` файлом, он добавляет элементы MSBuild `<Import>` в файл проекта, указывая на `.targets` и `.props` файла. (Файлы `.props` добавляются в начале файла проекта, а файлы `.targets` — в конце.) Отдельный условный элемент MSBuild `<Import>` добавляется в каждую требуемую версию .NET Framework.

Файлы MSBuild `.props` и `.targets` для трансграничного таргетинга можно поместить в папку `\buildMultiTargeting`. Во время установки пакета NuGet добавляет соответствующие элементы `<Import>` в файл проекта с условием, что требуемую версию .NET Framework не задано (свойство MSBuild `$(TargetFramework)` должно быть пустым).

В NuGet 3.x целевые объекты не добавляются в проект, а предоставляются через `{projectName}.nuget.g.targets` и `{projectName}.nuget.g.props`.

## <a name="run-nuget-pack-to-generate-the-nupkg-file"></a>Выполнение команды nuget pack для создания файла NUPKG

Чтобы создать пакет на основе сборки или рабочего каталога, соответствующего соглашениям, выполните команду `nuget pack`, указав файл `.nuspec`, где `<project-name>` необходимо заменить на имя файла:

```cli
nuget pack <project-name>.nuspec
```

При использовании проекта Visual Studio выполните команду `nuget pack`, указав файл проекта. В результате автоматически загрузится файл `.nuspec` проекта, и все токены в нем будут заменены значениями из файла проекта.

```cli
nuget pack <project-name>.csproj
```

> [!Note]
> Использование файла проекта напрямую является необходимым для замены токенов, так как проект является источником значений токенов. Замена токенов не производится при использовании команды `nuget pack` с файлом `.nuspec`.

В любом случае команда `nuget pack` исключает папки, начинающиеся с точки, например `.git` или `.hg`.

NuGet указывает, есть ли в файле `.nuspec` ошибки, требующие исправления, например, если вы забыли изменить значения-заполнители в манифесте.

После успешного выполнения команды `nuget pack` вы получаете файл `.nupkg`, который можно опубликовать в подходящей коллекции, как описано в разделе [Публикация пакета](../nuget-org/publish-a-package.md).

> [!Tip]
> После создания пакета его полезно просмотреть, открыв в средстве [Обозреватель пакетов](https://github.com/NuGetPackageExplorer/NuGetPackageExplorer). В нем в графической форме представлено содержимое пакета и его манифест. Вы также можете переименовать полученный файл `.nupkg` в файл `.zip` и просмотреть его содержимое напрямую.

### <a name="additional-options"></a>Дополнительные параметры

С командой `nuget pack` можно использовать различные параметры командной строки для исключения файлов, переопределения номера версии в манифесте, изменения папки выходных данных и совершения других действий. Полный список параметров см. в [справочнике по команде pack](../reference/cli-reference/cli-ref-pack.md).

Ниже приводятся некоторые часто используемые с проектами Visual Studio параметры.

- **Проекты, на которые указывают ссылки**. Если проект ссылается на другие проекты, вы можете включить их в пакет или добавить в качестве зависимостей с помощью параметра `-IncludeReferencedProjects`.

    ```cli
    nuget pack MyProject.csproj -IncludeReferencedProjects
    ```

    Включение является рекурсивным, поэтому если `MyProject.csproj` ссылается на проекты B и C, а они ссылаются на проекты D, E и F, в пакет включаются файлы из проектов B, C, D, E и F.

    Если в проекте, на который указывает ссылка, есть собственный файл `.nuspec`, NuGet вместо этого добавляет проект как зависимость.  Такой проект необходимо упаковать и опубликовать отдельно.

- **Конфигурация сборки**. По умолчанию NuGet использует стандартную конфигурацию сборки, указанную в файле проекта. Обычно это конфигурация *Debug*. Чтобы упаковать файлы из другой конфигурации сборки, например *Release*, используйте параметр `-properties`, указав конфигурацию:

    ```cli
    nuget pack MyProject.csproj -properties Configuration=Release
    ```

- **Символы**. Чтобы включить символы, позволяющие пользователям осуществлять пошаговое выполнение кода в пакете, используйте параметр `-Symbols`:

    ```cli
    nuget pack MyProject.csproj -symbols
    ```

### <a name="test-package-installation"></a>Тестирование установки пакета

Перед публикацией пакета, как правило, необходимо протестировать процесс его установки в проекте. Это позволяет убедиться в том, что все необходимые файлы помещаются в нужные места.

Установку можно протестировать вручную в Visual Studio или в командной строке, выполнив стандартную [процедуру установки пакета](../consume-packages/overview-and-workflow.md#ways-to-install-a-nuget-package).

Для автоматического тестирования выполните указанные ниже основные действия.

1. Скопируйте файл `.nupkg` в локальную папку.
1. Добавьте эту папку в источники пакета с помощью команды `nuget sources add -name <name> -source <path>` (см. описание [команды nuget sources](../reference/cli-reference/cli-ref-sources.md)). Обратите внимание на то, что на каждом компьютере этот локальный источник необходимо задать только один раз.
1. Установите пакет из источника с помощью команды `nuget install <packageID> -source <name>`, где `<name>` соответствует имени источника, предоставленному команде `nuget sources`. Указание источника позволяет гарантировать, что пакет будет устанавливаться только из него.
1. В файловой системе проверьте, правильно ли установились файлы.

## <a name="next-steps"></a>Следующие шаги

Создав пакет, то есть файл `.nupkg`, вы можете опубликовать его в любой коллекции на ваш выбор, как описано в разделе [Публикация пакета](../nuget-org/publish-a-package.md).

Вы также можете расширить возможности пакета или обеспечить поддержку других сценариев, как описано в следующих разделах:

- [Управление версиями пакета](../concepts/package-versioning.md)
- [Поддержка нескольких целевых платформ](../create-packages/supporting-multiple-target-frameworks.md)
- [Преобразования исходных файлов и файлов конфигурации](../create-packages/source-and-config-file-transformations.md)
- [Локализация](../create-packages/creating-localized-packages.md)
- [Предварительные версии](../create-packages/prerelease-packages.md)
- [Определение типа пакета](../create-packages/set-package-type.md)
- [Создание пакетов, содержащих сборки COM-взаимодействия](../create-packages/author-packages-with-COM-interop-assemblies.md)

Наконец, существуют дополнительные типы пакетов, о которых нужно знать:

- [Собственные пакеты](../guides/native-packages.md)
- [Пакеты символов](../create-packages/symbol-packages-snupkg.md)
